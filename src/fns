#!/bin/bash

# Constants.
readonly VALID_VAR='^[a-zA-Z_][a-zA-Z0-9_]*$'
readonly TOKEN_PIPE="|"

# be_variable simply outputs the variable.
be_variable() {
  local var="$1"
  local fn=""
  local tmp=""
  declare -a args

  IFS="$TOKEN_PIPE" read -ra parts <<< "$1"
  for i in "${!parts[@]}"; do 
    if [[ $i -eq 0 ]]; then
      # Variable name.
      var="${parts[$i]}"
    elif [[ $i -gt 0 ]]; then
      # Function name.
      fn="${parts[$i]}"
      # Process arguments, if any.
      read -ra sparts <<< "$fn"
      for x in "${!sparts[@]}"; do
        if [[ $x -eq 0 ]]; then
          # Fix function name.
          fn="${sparts[$x]}"
        else
          if [[ "${sparts[$x]}" =~ $VALID_VAR ]]; then
            local value="${!sparts[$x]}"
            if [[ -n "$value" ]]; then
              args+=("$value")
            else
              args+=("${sparts[$x]}")
            fi
          else
            # Not a valid variable, just add it as-is.
            args+=("${sparts[$x]}")
          fi
        fi
      done

      fn="$(to_lowercase "$fn")"
      if ! type "be_$fn" &>/dev/null; then
        # Function does not exist, return the variable as-is.
        tmp="${!var}"
        break
      else
        # Function exists, run it with the variable and arguments.
        if [[ -z "$tmp" ]]; then
          tmp=$(echo "${!var}" | be_"$fn" "${args[@]}")
        else
          tmp=$(echo "$tmp" | be_"$fn" "${args[@]}")
        fi
      fi
    fi
  done

  if [[ -z "$fn" ]]; then
    # No pipe method detected, just return the variable.
    if [[ "$var" =~ $VALID_VAR ]]; then
      echo "${!var}"
    else
      # Not a valid variable, return as-is.
      echo "$var"
    fi
  else
    # Return the processed piped variable.
    echo "$tmp"
  fi
}

# be_include handles including a partial in a template.
# It is ran through be.
be_include() {
  local contents=""
  contents="$(cat -)"
  echo "$contents" | be
}

# be_if handles checking if a variable is truthy.
# If so, the block contents will be displayed.
# If not, the block will be removed.
# Block contents is ran through be.
be_if() {
  local block=""
  local value=""

  block=$(cat -)
  value="${!1}"
  if [[ -n "$value" ]]; then
    # Passed, return parsed version of block.
    local parsed
    parsed=$(echo "$block" | be)
    echo "$parsed"
  else
    # Failed, return nothing.
    echo ""
  fi
}

# be_unless handles checking if a variable is empty or not defined.
# If so, the block will be removed.
# If not, the block contents will be displayed.
# Block contents is ran through be.
be_unless() {
  local block=""
  local value=""

  block=$(cat -)
  value="${!1}"
  if [[ -z "$value" ]]; then
    # Passed, return parsed version of block.
    local parsed
    parsed=$(echo "$block" | be)
    echo "$parsed"
  else
    # Failed, return nothing.
    echo ""
  fi
}

# be_function will run a custom function.
# If arguments exist, they will be passed to the custom function.
# Block content will be piped to the function.
be_function() {
  local fn=""
  local block=""
  local index=0
  declare -a args

  # Build out the list of arguments, if any.
  block=$(cat -)
  for part in $1; do
    if [[ $index -eq 0 ]]; then
      fn=$part
    else
      if [[ "${sparts[$x]}" =~ $VALID_VAR ]]; then
        local value="${!part}"
        if [[ -n "$value" ]]; then
          args+=("$value")
        else
          args+=("$part")
        fi
      else
        # Not a valid variable, just add it as-is.
        args+=("$part")
      fi
    fi

    ((index++))
  done

  fn=$(to_lowercase "$fn")
  if ! type "be_$fn" &>/dev/null; then
    # Function does not exist, return the block as-is.
    echo "$block"
  else
    echo "$block" | be_"$fn" "${args[@]}"
  fi
}

# be_foreach will loop block contents with provided variable and optional delimiter.
# {{VALUE}} and {{KEY}} are special inside the block contents, it will be replaced
# respectively with the value and key of the object.
be_foreach() {
  local vals
  local parsed=""
  local tmp=""
  local value=""
  local block=""
  block=$(cat -)

  if [[ -z "$2" ]]; then
    # No delimiter passed in.
    vals="${!1}"
  else
    # Delimiter passed in.
    if [[ "$1" =~ $VALID_VAR ]]; then
      # Valid variable, read it as an array.
      readarray -d "$2" -t vals <<< "${!1}"
    else
      # Not a valid variable, just split the string.
      IFS="$2" read -ra vals <<< "$1"
    fi
  fi

  # Inital loop values.
  FIRST=""
  LAST=""
  KEY=""
  KEY0=""
  KEY1=""
  VALUE=""
  for key in "${!vals[@]}"; do
    KEY="$key"
    KEY0="$key"
    KEY1=$((key + 1))
    VALUE=${vals[$key]}

    # First index handling.
    if [[ "$key" -eq 0 ]]; then
      FIRST="true"
    else
      unset FIRST
    fi

    # Last index handling.
    li=$(( ${#vals[@]} - 1 ))
    if [[ "$key" -eq "$li" ]]; then
      LAST="true"
    else
      unset LAST
    fi

    parsed="${parsed}$(echo "$block" | be)"
  done
  # Reset loop values.
  unset FIRST
  unset LAST
  unset KEY
  unset KEY0
  unset KEY1
  unset VALUE

  echo "$parsed"
}
