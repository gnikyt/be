#!/bin/bash

# TOKEN_MATCH represents the REGEX for token detection.
# Format of `{{(#|^|>|@)(KEY)}}(CONTENT)({{/(KEY)}})`.
readonly TOKEN_MATCH='\{\{([#^>%@])?([^\}]+?)\}\}(?:(?R)|.)*?\{\{/\2\}\}|\{\{[\w#^>%@./,\|\- ]+\}\}'

# Operations.
readonly OP_UNLESS="unless"
readonly OP_IF="if"
readonly OP_INCLUDE="include"
readonly OP_VARIABLE="variable"
readonly OP_FUNCTION="function"

# Tokens.
readonly TOKEN_OPEN_BRACE="{"
readonly TOKEN_CLOSE_BRACE="}"
readonly TOKEN_CLOSE_SLASH="/"
readonly TOKEN_OP_UNLESS="^"
readonly TOKEN_OP_IF="#"
readonly TOKEN_OP_INCLUDE=">"
readonly TOKEN_OP_FUNCTION="@"

# be will parse the template and replace variables or run operations.
# Variables:
#   {{HANDLE}}
#   {{HANDLE|UPPERCASE}}
#   {{HANDLE|UPPERCASE|TRIM left|REPLACE - _}}
# If:
#   {{#HANDLE}}We have a handle, its {{HANDLE}}!{{/HANDLE}}
# Unless:
#   {{^HANDLE}}We do not have a handle!{{/HANDLE}}
# Partials:
#   {{>templates/_partial.html}}
# Functions:
#   {{@FOREACH VAR DEL}}{{KEY}}:{{VALUE}}{{^LAST}}, {{/LAST}}{{/FOREACH VAR DEL}}
# Custom functions:
#   {{@FUNCTION_NAME arg1 arg2 arg3}}...{{/FUNCTION_NAME arg1 arg2 arg3}}
# Etc...
#
# Goal was to stick close to Mustache features and a high-level.
# Nesting is supported as well.
# This works by finding all matches of the template syntax, then
# going through each match one by one.
# With each match, each character is inspected one by one.
# By going through each character and positions, the applicable
# template action is determined and then processed.
be() {
  local match=""
  local input=""
  input=$(cat -)
  # Was honestly unable to figure out how to get the TOKEN_MATCH or pcregrep to work with newlines.
  input="${input//$'\n'/__NEWLINE__}"

  # Loop all matches.
  while match=$(echo "$input" | pcregrep -M -o "$TOKEN_MATCH" | head -n 1); [ -n "$match" ]; do
    local prev_char=""
    local next_char=""
    local index=0
    local block_start_index=0
    local in_expr=0
    local is_close=0
    local is_block=0
    local block=""
    local expr=""
    local op=""
    local parsed=""

    while read -r -N1 char; do
      next_char=${match:$index+1:1}
      case $char in
        # Handle opening brace of expression.
        "$TOKEN_OPEN_BRACE")
          if [[ "$prev_char" = "$TOKEN_OPEN_BRACE" ]]; then
            in_expr=1
            if [[ "$next_char" = "$TOKEN_CLOSE_SLASH" ]]; then
              # Next character is slash, this expression is a closing one.
              is_close=1
            fi
          fi
          ;;

        # Handle close brace of expression.
        "$TOKEN_CLOSE_BRACE")
          if [[ "$prev_char" = "$TOKEN_CLOSE_BRACE" ]]; then
            in_expr=0
            if [[ "$op" = "" ]]; then
              # No operation found. Variable output.
              op="$OP_VARIABLE"
            elif [[ $is_block -eq 1 ]]; then
              # We need to break out and handle seperately.
              block_start_index=$((index+1))
              is_block=0
              break
            fi
          fi
          ;;

        # If operation.
        "$TOKEN_OP_IF")
          if [[ $in_expr -eq 1 ]]; then
            expr=""
            op="$OP_IF"
            is_block=1
          fi
          ;;

        # Unless operation.
        "$TOKEN_OP_UNLESS")
          if [[ $in_expr -eq 1 ]]; then
            expr=""
            op="$OP_UNLESS"
            is_block=1
          fi
          ;;

        # Include of partial operation.
        "$TOKEN_OP_INCLUDE")
          if [[ $in_expr -eq 1 ]]; then
            expr=""
            op="$OP_INCLUDE"
          fi
          ;;

        # Function operation.
        "$TOKEN_OP_FUNCTION")
          if [[ $in_expr -eq 1 ]]; then
            expr=""
            op="$OP_FUNCTION"
            is_block=1
          fi
          ;;

        # Handle any other characer.
        *)
          if [[ $in_expr -eq 1 ]]; then
            if [[ $is_close -eq 0 ]]; then
              expr="$expr$char"
            fi
          fi
          ;;
      esac

      # Record this character, increase index.
      prev_char="$char"
      ((index++))
    done < <(echo -n "$match")

    case "$op" in
      # Handle include of partial.
      "$OP_INCLUDE")
        parsed=$(be_include "$expr")
        input="${input/"$match"/"$parsed"}"
        ;;

      # Handle if.
      "$OP_IF")
        block=$(echo "$match" | extract_block "$expr" "$block_start_index")
        parsed=$(echo "$block" | be_if "$expr")
        input="${input/"$match"/"$parsed"}"
        ;;

      # Handle unless.
      "$OP_UNLESS")
        block=$(echo "$match" | extract_block "$expr" "$block_start_index")
        parsed=$(echo "$block" | be_unless "$expr")
        input="${input/"$match"/"$parsed"}"
        ;;

      # Handle variables.
      "$OP_VARIABLE")
        parsed=$(be_variable "$expr")
        input="${input/"$match"/"$parsed"}"
        ;;

      # Handle functions.
      "$OP_FUNCTION")
        block=$(echo "$match" | extract_block "$expr" "$block_start_index")
        result=$(echo "$block" | be_function "$expr")
        input="${input/"$match"/"$result"}"
        ;;

      # Unknown, skip.
      *)
        ;;
    esac
  done

  input="${input//__NEWLINE__/$'\n'}"
  echo "$input"
}
